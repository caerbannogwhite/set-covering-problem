
#include "balas_dense.hpp"

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the indeces of the Balas cut
 * generated by the current solution. The indeces are provided
 * in the wSet structure.
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param wSet - the indeces of the Balas cut generated by this function
 * @return 
 */
int baldns_cut_proc(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
                        double zLow, std::set<int> &wSet)
{
    int colIdx, rowIdx;
    size_t i, j;
    double tmp1, tmp2, val;

    std::unique_ptr<arma::vec> res(new arma::vec());

    std::unique_ptr<std::set<int>> inter_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> union_ptr(new std::set<int>());

    std::unique_ptr<std::set<int>> qSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> sSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> txSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> jSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> matjSet_ptr(new std::set<int>());

    // initialize set S
    for (j = mat.n_cols; j--;)
    {
        if ((fabs(x(j) - 1.0) < SC_EPSILON_SMALL) && (s(j) > 0))
        {
            (*sSet_ptr).insert(j);
        }
    }

    // intialize T(x) set
    (*res) = mat * x;
    for (i = mat.n_rows; i--;)
    {
        if (fabs((*res)(i)-1.0) < SC_EPSILON_SMALL)
        {
            (*txSet_ptr).insert(i);
        }
    }

    while (true)
    {
        tmp1 = -INFINITY;
        tmp2 = INFINITY;
        for (auto jt = (*sSet_ptr).cbegin(); jt != (*sSet_ptr).cend(); ++jt)
        {
            tmp1 = (s(*jt) > tmp1) ? s(*jt) : tmp1;
            tmp2 = (s(*jt) >= (zUpp - zLow)) && (s(*jt) < tmp2) ? s(j) : tmp2;
        }

        val = tmp1 > tmp2 ? tmp2 : tmp1;

        // fill set J: column j in set S such that s[j] == val
        // fill set Q: column j in set S such that s[j] >= val
        (*jSet_ptr).clear();
        (*qSet_ptr).clear();
        for (auto jt = (*sSet_ptr).cbegin(); jt != (*sSet_ptr).cend(); ++jt)
        {
            if (fabs(val - s(*jt)) < SC_EPSILON_SMALL)
            {
                (*jSet_ptr).insert(*jt);
            }

            if (s(*jt) >= val)
            {
                (*qSet_ptr).insert(*jt);
            }
        }

        // fill M_J
        (*matjSet_ptr).clear();
        for (auto jt = (*jSet_ptr).cbegin(); jt != (*jSet_ptr).cend(); ++jt)
        {
            for (i = mat.n_rows; i--;)
            {
                if (mat(i, *jt) > 0.5)
                {
                    (*matjSet_ptr).insert(i);
                }
            }
        }

        rowIdx = -1;
        tmp1 = INFINITY;

        // find the intersection between set T(x) and set M_J
        std::set_intersection((*txSet_ptr).begin(), (*txSet_ptr).end(), (*matjSet_ptr).begin(), (*matjSet_ptr).end(), std::inserter((*inter_ptr), (*inter_ptr).begin()));
        
        // get the union of set W and set Q
        std::set_union(wSet.begin(), wSet.end(), (*qSet_ptr).begin(), (*qSet_ptr).end(), std::inserter((*union_ptr), (*union_ptr).begin()));

        for (auto it = (*inter_ptr).cbegin(); it != (*inter_ptr).cend(); ++it)
        {
            tmp2 = 0.0;
            for (auto jt = (*union_ptr).cbegin(); jt != (*union_ptr).cend(); ++jt)
            {
                tmp2 += mat(*it, *jt);
            }

            if (tmp2 < tmp1)
            {
                tmp1 = tmp2;
                rowIdx = i;
            }
        }

        colIdx = -1;
        for (auto jt = (*jSet_ptr).cbegin(); jt != (*jSet_ptr).cend(); ++jt)
        {
            if (mat(rowIdx, *jt) > 0.5)
            {
                colIdx = *jt;
                break;
            }
        }

        zLow += s(colIdx);

        for (j = mat.n_cols; j--;)
        {
            if ((*qSet_ptr).find(j) == (*qSet_ptr).end())
            {
                if (mat(rowIdx, j) > 0.5)
                {
                    wSet.insert(j);
                }
            } else
            {
                if (mat(rowIdx, j) > 0.5)
                {
                    s(j) -= s(colIdx);
                }
            }
        }

        // check end condition
        if (zLow + SC_EPSILON_MED >= zUpp)
        {
            break;
        }

        // update set S
        (*sSet_ptr).erase(colIdx);
    }

    return 0;
}

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the sets to generate the Balas
 * branches as described in ...
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param branchSet - 
 * @param maxBranch - maximum number of brances allowed
 * @param maxSingl - maximum number of singletos allowed
 * @return 
 */
int baldns_branch_rule1(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
                             double zLow, std::vector<std::set<int>> branchSet,
                             const int maxBranch, const int maxSingl)
{
    int cnt, cntNonZero, cntSingl, p, colIdx, rowIdx;
    size_t i, j;
    double val, tmp1, tmp2;

    std::unique_ptr<arma::vec> res_ptr(new arma::vec());
    std::unique_ptr<arma::uvec> indeces_ptr(new arma::uvec());

    std::unique_ptr<std::set<int>> intersect_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> sSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> txSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> jSet_ptr(new std::set<int>());
    std::unique_ptr<std::set<int>> matjSet_ptr(new std::set<int>());

    // init S set
    for (j = mat.n_cols; j--;)
    {
        if ((fabs(x(j) - 1.0) < SC_EPSILON_SMALL) && (s(j) > 0.0))
        {
            (*sSet_ptr).insert(j);
        }
    }

    // inti T(x) set
    (*res_ptr) = mat * x;
    for (i = mat.n_rows; i--;)
    {
        if (fabs((*res_ptr)(i) - 1.0) < SC_EPSILON_SMALL)
        {
            (*txSet_ptr).insert(i);
        }
    }

    p = 0;
    cntNonZero = 0;
    cntSingl = 0;
    while (1)
    {
        tmp1 = -INFINITY;
        tmp2 = INFINITY;
        for (auto jt = (*sSet_ptr).cbegin(); jt != (*sSet_ptr).cend(); ++jt)
        {
            tmp1 = (s(*jt) > tmp1) ? s(*jt) : tmp1;
            tmp2 = (s(*jt) >= (zUpp - zLow)) && (s(*jt) < tmp2) ? s(j) : tmp2;
        }

        val = tmp1 > tmp2 ? tmp2 : tmp1;

        // fill J set
        (*jSet_ptr).clear();
        for (auto jt = (*sSet_ptr).cbegin(); jt != (*sSet_ptr).cend(); ++jt)
        {
            if (abs(val - s(*jt)) < SC_EPSILON_SMALL)
            {
                (*jSet_ptr).insert(*jt);
            }
        }

        // fill M_J set
        (*matjSet_ptr).clear();
        for (auto jt = (*jSet_ptr).cbegin(); jt != (*jSet_ptr).cend(); ++jt)
        {
            for (i = mat.n_rows; i--;)
            {
                if (fabs(mat(i, *jt) - 1.0) < SC_EPSILON_SMALL)
                {
                    (*matjSet_ptr).insert(i);
                }
            }
        }

        // fill Q_p
        (*indeces_ptr) = arma::find(s >= val);
        for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
        {
            branchSet[p].insert(j);
        }

        rowIdx = -1;
        tmp1 = INFINITY;

        // find the intersection between set T(x) and set M_J
        std::set_intersection((*txSet_ptr).begin(), (*txSet_ptr).end(), (*matjSet_ptr).begin(), (*matjSet_ptr).end(), std::inserter((*intersect_ptr), (*intersect_ptr).begin()));
        for (auto it = (*intersect_ptr).cbegin(); it != (*intersect_ptr).cend(); ++it)
        {
            // count all non-zero elements on i-th row that are not on p-th (current) branch set
            cnt = 0;
            (*indeces_ptr) = arma::find(mat.row(*it) > 0.5);
            for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
            {
                cnt += (branchSet[p].find(*jt) == branchSet[p].end());
            }

            if (cnt < tmp1)
            {
                tmp1 = cnt;
                rowIdx = i;
            }
        }

        colIdx = -1;
        for (auto jt = (*jSet_ptr).cbegin(); jt != (*jSet_ptr).cend(); ++jt)
        {
            if (mat(rowIdx, *jt) > 0.5)
            {
                colIdx = *jt;
                break;
            }
        }

        zLow += s(colIdx);

        cnt = 0;
        for (auto jt = branchSet[p].cbegin(); jt != branchSet[p].cend(); ++jt)
        {
            if (mat(rowIdx, *jt) > 0.5)
            {
                ++cnt;
                s(*jt) -= s(colIdx);
            }
        }

        cntSingl += (cnt == 1);
        cntNonZero += cnt;

        // check
        if ((zLow + SC_EPSILON_SMALL < zUpp) && (p + 1 == maxBranch))
        {
            return -1;
        } else
        if ((zLow + SC_EPSILON_SMALL < zUpp) && (cntSingl >= maxSingl))
        {
            return -1;
        } else
        if (zLow + SC_EPSILON_SMALL >= zUpp)
        {
            p++;
            break;
        }

        (*sSet_ptr).erase(colIdx);
        p++;
    }

    return (cntNonZero > p * log2(p)) ? p : -1;
}

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the sets to generate the Balas
 * branches as described in ...
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param branchSet - 
 * @param maxBranch - maximum number of brances allowed
 * @param maxSingl - maximum number of singletos allowed
 * @return 
 */
int baldns_branch_rule1_test(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
                             double zLow, std::vector<std::unordered_set<int>> branchSet,
                             const int maxBranch, const int maxSingl)
{
    int p, cnt, cntNonZero, cntSingl, colIdx;
    size_t j;
    double val;
    std::unique_ptr<std::unordered_set<int>> sSet_ptr (new std::unordered_set<int>());

    // init set S
    for (j = mat.n_cols; j--;)
    {
        if (((fabs(x(j))- 1.0) < SC_EPSILON_SMALL) && (s(j) > 0.0))
        {
            (*sSet_ptr).insert(j);
        }
    }

    p = 0;
    cntNonZero = 0;
    cntSingl = 0;
    while (true)
    {
        // get the index of the column with maximum reduced cost
        val = -INFINITY;
        for (auto it = (*sSet_ptr).cbegin(); it != (*sSet_ptr).cend(); ++it)
        {
            if (s(j) > val)
            {
                val = s(j);
                colIdx = *it;
            }
        }

        // fill Q_p
        cnt = 0;
        for (j = 0; j < mat.n_cols; ++j)
        {
            if ((s(j) >= val) && ((*sSet_ptr).find(j) == (*sSet_ptr).end()))
            {
                branchSet[p].insert(j);
                ++cnt;
            }
        }

        //cnt += (!qmatr[jt]);
        //qmatr[jt] = 1;

        cntSingl += (cnt == 1);
        cntNonZero += cnt;

        zLow += val;

        // check
        if ((zLow + SC_EPSILON_SMALL < zUpp) && ((p + 1) == maxBranch))
        {
            return -1;
        } else
        if ((zLow + SC_EPSILON_SMALL < zUpp) && (cntSingl >= maxSingl))
        {
            return -1;
        } else
        if (zLow + SC_EPSILON_SMALL >= zUpp)
        {
            p++;
            break;
        }

        // update reduced costs vector
        for (auto it = branchSet[p].cbegin(); it != branchSet[p].cend(); ++it)
        {
            s(*it) -= val;
        }

        (*sSet_ptr).erase(colIdx);
        p++;
    }

    return (cntNonZero > p * log2(p)) ? p : -1;
}

int baldns_over_sat_rows(arma::mat &mat, arma::vec &x)
{
    size_t i;
    double cnt;

    std::unique_ptr<arma::uvec> indeces_ptr(new arma::uvec());
    std::unique_ptr<arma::uvec> supp_ptr(new arma::uvec());
    std::unique_ptr<arma::vec> matDotX_ptr(new arma::vec());

    (*supp_ptr) = arma::find(x > 0.5);
    (*matDotX_ptr) = mat * x;

    for (auto jt = (*supp_ptr).cbegin(); jt != (*supp_ptr).cend(); ++jt)
    {
        cnt = 0.0;
        (*indeces_ptr) = arma::find((*matDotX_ptr) > 1.0);
        for (auto it = (*indeces_ptr).cbegin(); it != (*indeces_ptr).cend(); ++jt)
        {
            cnt += mat(*it, *jt);
        }

        if (cnt > 0.0)
        {
            (*matDotX_ptr) -= mat.col(*jt);
            x(*jt) = 0.0;
        }
    }

    return 0;
}

/**
 * Given a SCP matrix and a SCP solution x,
 * return the number of removed columns
 * from x (to make x a prime cover).
 * 
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP solution
 * @return the number of removed columns from x
 */
int baldns_make_prime_cover(const arma::mat &mat, arma::vec &x)
{
    int cntRemoved;
    size_t i, j;

    std::unique_ptr<arma::vec> matDotX_ptr (new arma::vec(mat.n_rows));
    *matDotX_ptr = mat * x;

    cntRemoved = 0;
    for (j = mat.n_cols; j--;)
    {
        if (x(j) > SC_EPSILON_SMALL)
        {
            x(j) = 0.0;
            for (i = 0; i < mat.n_rows; ++i)
            {
                if ((mat(i, j) > SC_EPSILON_SMALL) && ((*matDotX_ptr)(i) < 2.0))
                {
                    x(j) = 1.0;
                    break;
                }
            }

            if (x(j) < SC_EPSILON_SMALL)
            {
                cntRemoved++;
                (*matDotX_ptr) -= mat.col(j);
            }
        }
    }

    return cntRemoved;
}

/**
 * Given a SCP dense matrix mat and a solution vector x,
 * return true if x is a cover for mat, false otherwise.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a SCP solution vector
 * @return true if x covers mat, false otherwise
 */
bool baldns_is_cover(const arma::mat &mat, arma::vec &x)
{
    bool flag;

    std::unique_ptr<arma::vec> matDotX_ptr(new arma::vec(mat.n_rows));
    *matDotX_ptr = mat * x;

    flag = true;
    for (auto it = (*matDotX_ptr).cbegin(); it != (*matDotX_ptr).cend(); ++it)
    {
        if (*it < 1.0)
        {
            flag = false;
            break;
        }
    }

    return flag;
}

/**
 * Primal heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * @param mat - arma::mat SCP matrix
 * @param obj - arma::vec SCP objective values
 * @param x - arma::vec a solution for the SCP
 * @param xSupp - 
 * @param whichFunc - select function for heuristic
 * @return the value of the best primal solution found
 */
double baldns_heur_primal_0(arma::mat &mat, arma::vec &obj,
                            arma::vec &x, const int whichFunc)
{
    int colIdx, rowIdx;
    size_t i, j, coveredRows;
    double bestVal, val, zUpp, cnt;
    double (*func)(const double, const double);

    std::unique_ptr<std::vector<std::pair<int, int>>> rSet_ptr (new std::vector<std::pair<int, int>>);

    // all the functions defined by Balas and Ho
    // plus the last two defined by Vasko and Wilson
    switch (whichFunc)
    {
    case 1:
        func = [](const double c, const double k) -> double { return c; };
        break;
    case 2:
        func = [](const double c, const double k) -> double { return c / k; };
        break;
    case 3:
        func = [](const double c, const double k) -> double { return k < 2 ? c : c / log2(k); };
        break;
    case 4:
        func = [](const double c, const double k) -> double { return k < 2 ? c / k : c / k * log2(k); };
        break;
    case 5:
        func = [](const double c, const double k) -> double { return k < 3 ? c / k : c / k * log(k); };
        break;
    case 6:
        func = [](const double c, const double k) -> double { return c / (k * k); };
        break;
    case 7:
        func = [](const double c, const double k) -> double { return sqrt(c) / (k * k); };
        break;
    default:
        func = [](const double c, const double k) -> double { return k < 2 ? c : c / log2(k); };
        break;
    }

    // get the starting value of the current solution x
    zUpp = arma::dot(obj, x);

    // find the number of already covered rows
    coveredRows = 0;
    for (i = mat.n_rows; i--;)
    {
        val = arma::dot(mat.row(i), x);
        cnt = round(arma::sum(mat.row(i)));

        if (fabs(val) < SC_EPSILON_SMALL)
        {
            (*rSet_ptr).push_back(std::make_pair(cnt, i));
        }
        else
        {
            coveredRows++;
        }
    }

    /*std::cout << "cov rows = " << coveredRows << std::endl;
    std::cout << "rows = " << std::endl;
    for (auto it : *rSet_ptr)
    {
        std::cout << it.first << " " << it.second << std::endl; 
    }*/

    // sort not covered rows by decreasing number of
    // non-zero elements in the row (read rSet_ptr from back to front)
    std::sort((*rSet_ptr).begin(), (*rSet_ptr).end(), [](std::pair<int, int> a, std::pair<int, int> b) -> bool { return a.first < b.first; });

    std::cout << "\n\nBALAS HEUR 0\n";
    std::cout << "sort rows = " << std::endl;
    for (auto it : *rSet_ptr)
    {
        std::cout << it.first << " " << it.second << std::endl;
    }

    while (coveredRows < mat.n_rows)
    {
        // get last element of R
        rowIdx = (*rSet_ptr).back().second;
        (*rSet_ptr).pop_back();

        bestVal = INFINITY;
        colIdx = -1;
        for (j = 0; j < mat.n_cols; ++j)
        {
            // if mat[row, col] is 0 or if x(col) is already taken, skip this column
            if ((fabs(mat(rowIdx, j)) < SC_EPSILON_SMALL) || (x(j) > SC_EPSILON_SMALL))
            {
                continue;
            }

            val = arma::sum(mat.col(j));

            // use the column j that minimise the value
            // of the selected function
            if (func(obj(j), val) < bestVal)
            {
                bestVal = func(obj(j), val);
                colIdx = j;
            }
        }

        std::cout << "row = " << rowIdx << " col = " << colIdx << " cov rows = " << coveredRows << std::endl;

        x(colIdx) = 1.0;
        zUpp += obj(colIdx);

        // remove covered rows
        for (auto it = (*rSet_ptr).begin(); it != (*rSet_ptr).end();)
        {
            if (fabs(mat((*it).second, colIdx) - 1.0) < SC_EPSILON_SMALL)
            {
                coveredRows++;
                (*rSet_ptr).erase(it);
            } else
            {
                ++it;
            }
        }
    }

    // make the cover found a prime cover
    baldns_make_prime_cover(mat, x);

    return zUpp;
}

double baldns_heur_primal_12(arma::mat &mat, arma::vec &obj, arma::vec &x)
{
    double zu, zu1, zu2;

    std::unique_ptr<arma::vec> x1_ptr(new arma::vec());
    std::unique_ptr<arma::vec> x2_ptr(new arma::vec());

    zu = baldns_heur_primal_0(mat, obj, x, 3);

    // First round
    baldns_over_sat_rows(mat, x);

    zu1 = baldns_heur_primal_0(mat, obj, *x1_ptr, 1);
    zu2 = baldns_heur_primal_0(mat, obj, *x2_ptr, 2);
    
    if ((zu1 < zu2) && (zu1 < zu))
    {
        x = *x1_ptr;
        zu = zu1;
    }
    else if ((zu2 < zu1) && (zu2 < zu))
    {
        x = *x1_ptr;
        zu = zu2;
    }
    
    // Second round
    baldns_over_sat_rows(mat, x);

    zu1 = baldns_heur_primal_0(mat, obj, *x1_ptr, 4);
    zu2 = baldns_heur_primal_0(mat, obj, *x2_ptr, 5);

    if ((zu1 < zu2) && (zu1 < zu))
    {
        x = *x1_ptr;
        zu = zu1;
    }
    else if ((zu2 < zu1) && (zu2 < zu))
    {
        x = *x1_ptr;
        zu = zu2;
    }

    return zu;
}

double baldns_heur_primal_5b(arma::mat &mat, arma::vec &obj, arma::vec &x,
                                arma::vec &s, arma::vec &u)
{
    int cntCoveredRows, rowIdx;
    size_t i;
    double zUpp, val;

    std::unique_ptr<std::unordered_set<int>> rSet_ptr; 

    std::unique_ptr<arma::uvec> indeces_ptr(new arma::uvec());
    std::unique_ptr<arma::vec> matDotX_ptr(new arma::vec());

    (*indeces_ptr) = arma::find(s < SC_EPSILON_SMALL);
    for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
    {
        x(*jt) = 1.0;
    }
    
    baldns_make_prime_cover(mat, x);

    (*matDotX_ptr) = mat * x;
    cntCoveredRows = 0;
    for (i = mat.n_rows; i--;)
    {
        if ((*matDotX_ptr)(i) < 0.5)
        {
            (*rSet_ptr).insert(i);
        } else {
            ++cntCoveredRows;
        }
    }
    //printf("bhp5 ok4 cvdrows=%d rsetlen=%d\n", cvdrows, rsetlen);

    while ((*rSet_ptr).size() > 0)
    {
        // get a row not covered
        rowIdx = *(*rSet_ptr).begin();
        (*rSet_ptr).erase(rowIdx);

        val = INFINITY;
        (*indeces_ptr) = arma::find(mat.row(rowIdx) > 0.5);
        for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
        {
            if (s(*jt) < val)
            {
                val = s(*jt);
            }
        }
        
        u(rowIdx) += val;

        for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
        {
            s(*jt) -= val;
        }

        (*indeces_ptr) = arma::find(s < SC_EPSILON_SMALL);
        for (auto jt = (*indeces_ptr).cbegin(); jt != (*indeces_ptr).cend(); ++jt)
        {
            x(*jt) = 1.0;
        }

        baldns_make_prime_cover(mat, x);

        (*matDotX_ptr) = mat * x;
        cntCoveredRows = 0;
        for (i = mat.n_rows; i--;)
        {
            if ((*matDotX_ptr)(i) < 0.5)
            {
                (*rSet_ptr).insert(i);
            }
            else
            {
                ++cntCoveredRows;
            }
        }
    }

    baldns_make_prime_cover(mat, x);

    zUpp = arma::dot(obj, x);

    return zUpp;
}

bool baldns_is_dual_sol(arma::mat &mat, arma::vec &obj, arma::vec &u)
{
    size_t j;

    std::unique_ptr<arma::vec> res_ptr(new arma::vec());

    (*res_ptr) = u * mat - obj;


    return true;
}

/**
 * Dual heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a primal solution
 * @param u - arma::vec dual vector
 * @param s - arma::vec reduced costs vector
 * @return
 */
int baldns_heur_dual_1(arma::mat &mat, arma::vec &x, arma::vec &u, arma::vec &s)
{
    bool firstTime;
    size_t cnt, i, j, rowIdx;
    double val;

    std::unique_ptr<std::vector<std::pair<int, int>>> rSet_ptr(new std::vector<std::pair<int, int>>);

    u.fill(0.0);

    for (i = 0; i < mat.n_rows; ++i)
    {
        // No need to generate R and T(x) sets: val says how
        // much a row is covered and if val < 1 (minimum
        // cover) skip the row
        val = arma::dot(mat.row(i), x);
        cnt = round(arma::sum(mat.row(i)));

        if (fabs(val - 1.0) <  SC_EPSILON_SMALL)
        {
            (*rSet_ptr).push_back(std::make_pair(cnt, i));
        }
    }

    std::sort((*rSet_ptr).begin(), (*rSet_ptr).end(), [](std::pair<int, int> a, std::pair<int, int> b) -> bool { return a.first > b.first; });

    firstTime = true;
    while ((*rSet_ptr).size() > 0)
    {

        rowIdx = (*rSet_ptr).back().second;
        (*rSet_ptr).pop_back();

        u(rowIdx) = INFINITY;
        for (j = 0; j < mat.n_cols; ++j)
        {
            u(rowIdx) = mat(rowIdx, j) * (s(j) < u(rowIdx) ? s(j) : u(rowIdx));
        }

        s -= u(rowIdx) * mat.row(rowIdx);

        if (((*rSet_ptr).size() == 0) && firstTime)
        {
            firstTime = false;
            (*rSet_ptr).clear();

            for (i = 0; i < mat.n_rows; ++i)
            {
                // No need to generate R and T(x) sets: val says how
                // much a row is covered and if val < 1 (minimum
                // cover) skip the row
                val = arma::dot(mat.row(i), x);
                cnt = arma::sum(mat.row(i));

                if (fabs(val - 1.0) < SC_EPSILON_SMALL)
                {
                    (*rSet_ptr).push_back(std::make_pair(cnt, i));
                }
            }

            std::sort((*rSet_ptr).begin(), (*rSet_ptr).end(), [](std::pair<int, int> a, std::pair<int, int> b) -> bool { return a.first > b.first; });
        }
    }

    return 0;
}

/**
 * Dual heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a primal solution
 * @param u - arma::vec dual vector 
 * @param s - arma::vec reduced costs vector
 * @param zUpp - the value of current solution (x dot obj)
 * @return 
 */
int baldns_heur_dual_3(arma::mat &mat,arma::vec &x, arma::vec &u, arma::vec &s, const double zUpp)
{
    size_t i, rowIdx;
    double sDotX, zLow, val;

    std::unique_ptr<std::vector<std::pair<double, int>>> rSet_ptr(new std::vector<std::pair<double, int>>);

    sDotX = arma::dot(s, x);
    zLow = arma::sum(u);

    if (sDotX >= (zUpp - zLow))
    {
        return 0;
    }

    for (i = 0; i < mat.n_rows; ++i)
    {

        // No need to generate R and T(x) sets: val says how
        // much a row is covered and if val < 1 (minimum
        // cover) skip the row
        val = arma::dot(mat.row(i), x);

        if ((u(i) > 0) && (val > 1.0))
        {
            (*rSet_ptr).push_back(std::make_pair(val, i));
        }
    }

    if ((*rSet_ptr).size() == 0)
    {
        return 0;
    }

    std::sort((*rSet_ptr).begin(), (*rSet_ptr).end(), [](std::pair<double, int> a, std::pair<double, int> b) -> bool { return a.first > b.first; });

    while (sDotX < (zUpp - zLow - SC_EPSILON_SMALL))
    {
        rowIdx = (*rSet_ptr).back().second;
        (*rSet_ptr).pop_back();

        val = u(rowIdx);
        s += val * mat.row(rowIdx);
        sDotX += val * arma::dot(mat.row(rowIdx), x);

        zLow -= val;
        u(rowIdx) = 0.0;
    }

    return 0;
}
