
#include "balas_dense.hpp"

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the indeces of the Balas cut
 * generated by the current solution. The indeces are provided
 * in the wSet structure.
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param wSet - the indeces of the Balas cut generated by this function
 * @return 
 */
int baldns_separation_proc(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
						   double zLow, std::set<int> &wSet)
{
	int colIdx;
	int rowIdx;
	size_t i;
	size_t j;
	double tmp1;
	double tmp2;
	double val;

	std::unique_ptr<arma::vec> resPtr(new arma::vec());

	std::unique_ptr<std::set<int>> unionPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> qSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> sSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> tSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> jSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> mSetPtr(new std::set<int>());

	// initialize S set
	for (j = mat.n_cols; j--;)
	{
		if ((fabs(x(j) - 1.0) < SC_EPSILON_SMALL) && (s(j) > 0.0))
		{
			sSetPtr->insert(j);
		}
	}

	// intialize T(x) set
	(*resPtr) = mat * x;
	for (i = mat.n_rows; i--;)
	{
		if (fabs((*resPtr)(i) - 1.0) < SC_EPSILON_SMALL)
		{
			tSetPtr->insert(i);
		}
	}

	while (true)
	{
		tmp1 = -DBL_MAX;
		tmp2 = DBL_MAX;
		for (auto jt = sSetPtr->cbegin(); jt != sSetPtr->cend(); ++jt)
		{
			std::cout << "loop 01 - " << *jt << std::endl;
			tmp1 = (s(*jt) > tmp1) ? s(*jt) : tmp1;
			tmp2 = (s(*jt) >= (zUpp - zLow)) && (s(*jt) < tmp2) ? s(*jt) : tmp2;
		}

		val = tmp1 > tmp2 ? tmp2 : tmp1;

		// fill set J: column j in set S such that s[j] == val
		// fill set Q: column j in set S such that s[j] >= val
		jSetPtr->clear();
		qSetPtr->clear();
		for (auto jt = sSetPtr->cbegin(); jt != sSetPtr->cend(); ++jt)
		{
			std::cout << "loop 02 - " << *jt << std::endl;
			if (fabs(val - s(*jt)) < SC_EPSILON_SMALL)
			{
				jSetPtr->insert(*jt);
			}

			if (s(*jt) >= val)
			{
				qSetPtr->insert(*jt);
			}
		}

		// fill set M_J
		mSetPtr->clear();
		for (auto jt = jSetPtr->cbegin(); jt != jSetPtr->cend(); ++jt)
		{
			std::cout << "loop 03 - " << *jt << std::endl;
			for (i = mat.n_rows; i--;)
			{
				if (mat(i, *jt) >= 1.0)
				{
					mSetPtr->insert(i);
				}
			}
		}

		rowIdx = -1;
		tmp1 = DBL_MAX;

		// get the union of set W and set Q
		std::set_union(wSet.begin(), wSet.end(), qSetPtr->begin(), qSetPtr->end(), std::inserter(*unionPtr, unionPtr->begin()));

		// find the intersection between set T(x) and set M_J
		for (auto it = mSetPtr->cbegin(); it != mSetPtr->cend(); ++it)
		{
			if (tSetPtr->find(*it) != tSetPtr->end())
			{
				tmp2 = 0.0;
				for (auto jt = unionPtr->cbegin(); jt != unionPtr->cend(); ++jt)
				{
					//std::cout << "loop 04 - union - j = " << *jt << std::endl;
					tmp2 += mat(*it, *jt);
				}

				if (tmp2 < tmp1)
				{
					tmp1 = tmp2;
					rowIdx = *it;
				}
			}
		}

		std::cout << "rowIdx = " << rowIdx << std::endl;

		colIdx = -1;
		for (auto jt = jSetPtr->cbegin(); jt != jSetPtr->cend(); ++jt)
		{
			if (mat(rowIdx, *jt) >= 1.0)
			{
				colIdx = *jt;
				break;
			}
		}

		std::cout << "J = "; for (auto jt = jSetPtr->cbegin(); jt != jSetPtr->cend(); ++jt) std::cout << *jt << " "; std::cout << std::endl;
		std::cout << "M = ";
		for (auto it = mSetPtr->cbegin(); it != mSetPtr->cend(); ++it)
			std::cout << *it << " ";
		std::cout << std::endl;

		std::cout << "colIdx = " << colIdx << " - zUpp = " << zUpp << " - zLow = " << zLow << " - val = " << val << std::endl;
		zLow += s(colIdx);

		for (j = mat.n_cols; j--;)
		{
			//std::cout << "loop 06 - " << j << std::endl;
			if (qSetPtr->find(j) == qSetPtr->end())
			{
				if (mat(rowIdx, j) >= 1.0)
				{
					wSet.insert(j);
				}
			}
			else
			{
				if (mat(rowIdx, j) >= 1.0)
				{
					s(j) -= s(colIdx);
				}
			}
		}

		// check end condition
		if (zLow + SC_EPSILON_MED >= zUpp)
		{
			break;
		}

		// update set S
		sSetPtr->erase(colIdx);
	}

	return 0;
}

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the sets to generate the Balas
 * branches as described in ...
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param branchSet - 
 * @param maxBranch - maximum number of brances allowed
 * @param maxSingl - maximum number of singletos allowed
 * @return 
 */
int baldns_branch_rule1(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
						double zLow, std::vector<std::set<int>> branchSet,
						const int maxBranch, const int maxSingl)
{
	int cnt;
	int cntNonZero;
	int cntSingl;
	int p;
	int colIdx;
	int rowIdx;
	size_t i;
	size_t j;
	double val;
	double tmp1;
	double tmp2;

	std::unique_ptr<arma::vec> resPtr(new arma::vec());

	std::unique_ptr<arma::uvec> indecesPtr(new arma::uvec());

	std::unique_ptr<std::set<int>> interPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> sSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> tSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> jSetPtr(new std::set<int>());
	std::unique_ptr<std::set<int>> mSetPtr(new std::set<int>());

	// init S set
	for (j = mat.n_cols; j--;)
	{
		if ((fabs(x(j) - 1.0) < SC_EPSILON_SMALL) && (s(j) > 0.0))
		{
			sSetPtr->insert(j);
		}
	}

	// inti T(x) set
	(*resPtr) = mat * x;
	for (i = mat.n_rows; i--;)
	{
		if (fabs((*resPtr)(i) - 1.0) < SC_EPSILON_SMALL)
		{
			tSetPtr->insert(i);
		}
	}

	p = 0;
	cntNonZero = 0;
	cntSingl = 0;
	while (1)
	{
		tmp1 = -DBL_MAX;
		tmp2 = DBL_MAX;
		for (auto jt = sSetPtr->cbegin(); jt != sSetPtr->cend(); ++jt)
		{
			tmp1 = (s(*jt) > tmp1) ? s(*jt) : tmp1;
			tmp2 = (s(*jt) >= (zUpp - zLow)) && (s(*jt) < tmp2) ? s(j) : tmp2;
		}

		val = tmp1 > tmp2 ? tmp2 : tmp1;

		// fill J set
		jSetPtr->clear();
		for (auto jt = sSetPtr->cbegin(); jt != sSetPtr->cend(); ++jt)
		{
			if (abs(val - s(*jt)) < SC_EPSILON_SMALL)
			{
				jSetPtr->insert(*jt);
			}
		}

		// fill M_J set
		mSetPtr->clear();
		for (auto jt = jSetPtr->cbegin(); jt != jSetPtr->cend(); ++jt)
		{
			for (i = mat.n_rows; i--;)
			{
				if (fabs(mat(i, *jt) - 1.0) < SC_EPSILON_SMALL)
				{
					mSetPtr->insert(i);
				}
			}
		}

		// fill Q_p
		(*indecesPtr) = arma::find(s >= val);
		for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
		{
			branchSet[p].insert(j);
		}

		rowIdx = -1;
		tmp1 = DBL_MAX;

		// find the intersection between set T(x) and set M_J
		std::set_intersection(tSetPtr->begin(), tSetPtr->end(), mSetPtr->begin(), mSetPtr->end(), std::inserter(*interPtr, interPtr->begin()));
		for (auto it = interPtr->cbegin(); it != interPtr->cend(); ++it)
		{
			// count all non-zero elements on i-th row that are not on p-th (current) branch set
			cnt = 0;
			(*indecesPtr) = arma::find(mat.row(*it) > 0.5);
			for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
			{
				cnt += (branchSet[p].find(*jt) == branchSet[p].end());
			}

			if (cnt < tmp1)
			{
				tmp1 = cnt;
				rowIdx = i;
			}
		}

		colIdx = -1;
		for (auto jt = jSetPtr->cbegin(); jt != jSetPtr->cend(); ++jt)
		{
			if (mat(rowIdx, *jt) > 0.5)
			{
				colIdx = *jt;
				break;
			}
		}

		zLow += s(colIdx);

		cnt = 0;
		for (auto jt = branchSet[p].cbegin(); jt != branchSet[p].cend(); ++jt)
		{
			if (mat(rowIdx, *jt) > 0.5)
			{
				++cnt;
				s(*jt) -= s(colIdx);
			}
		}

		cntSingl += (cnt == 1);
		cntNonZero += cnt;

		// check
		if ((zLow + SC_EPSILON_SMALL < zUpp) && (p + 1 == maxBranch))
		{
			return -1;
		}
		else if ((zLow + SC_EPSILON_SMALL < zUpp) && (cntSingl >= maxSingl))
		{
			return -1;
		}
		else if (zLow + SC_EPSILON_SMALL >= zUpp)
		{
			p++;
			break;
		}

		sSetPtr->erase(colIdx);
		p++;
	}

	return (cntNonZero > p * log2(p)) ? p : -1;
}

/**
 * Given a SCP matrix, a feasible primal solution x, the reduced
 * costs vector s (of the current solution), the value of the current
 * solution zUpp (the dot product of obj and x), the value of the 
 * best dual solution zLow, return the sets to generate the Balas
 * branches as described in ...
 *  
 * @param mat - arma::mat a SCP matrix
 * @param x - arma::vec a SCP primal solution
 * @param s - arma::vec the reduced costs of solution x
 * @param zUpp - the value of the solution x
 * @param zLow - the value of the best dual solution known
 * @param branchSet - 
 * @param maxBranch - maximum number of brances allowed
 * @param maxSingl - maximum number of singletos allowed
 * @return 
 */
int baldns_branch_rule1_test(arma::mat &mat, arma::vec &x, arma::vec &s, double zUpp,
							 double zLow, std::vector<std::unordered_set<int>> branchSet,
							 const int maxBranch, const int maxSingl)
{
	int p;
	int cnt;
	int cntNonZero;
	int cntSingl;
	int colIdx;
	size_t j;
	double val;

	std::unique_ptr<std::unordered_set<int>> sSetPtr(new std::unordered_set<int>());

	// init set S
	for (j = mat.n_cols; j--;)
	{
		if (((fabs(x(j)) - 1.0) < SC_EPSILON_SMALL) && (s(j) > 0.0))
		{
			sSetPtr->insert(j);
		}
	}

	p = 0;
	cntNonZero = 0;
	cntSingl = 0;
	while (true)
	{
		// get the index of the column with maximum reduced cost
		val = -DBL_MAX;
		for (auto it = sSetPtr->cbegin(); it != sSetPtr->cend(); ++it)
		{
			if (s(j) > val)
			{
				val = s(j);
				colIdx = *it;
			}
		}

		// fill Q_p
		cnt = 0;
		for (j = 0; j < mat.n_cols; ++j)
		{
			if ((s(j) >= val) && (sSetPtr->find(j) == sSetPtr->end()))
			{
				branchSet[p].insert(j);
				++cnt;
			}
		}

		//cnt += (!qmatr[jt]);
		//qmatr[jt] = 1;

		cntSingl += (cnt == 1);
		cntNonZero += cnt;

		zLow += val;

		// check
		if ((zLow + SC_EPSILON_SMALL < zUpp) && ((p + 1) == maxBranch))
		{
			return -1;
		}
		else if ((zLow + SC_EPSILON_SMALL < zUpp) && (cntSingl >= maxSingl))
		{
			return -1;
		}
		else if (zLow + SC_EPSILON_SMALL >= zUpp)
		{
			p++;
			break;
		}

		// update reduced costs vector
		for (auto it = branchSet[p].cbegin(); it != branchSet[p].cend(); ++it)
		{
			s(*it) -= val;
		}

		sSetPtr->erase(colIdx);
		p++;
	}

	return (cntNonZero > p * log2(p)) ? p : -1;
}

int baldns_over_sat_rows(arma::mat &mat, arma::vec &x)
{
	double cnt;

	std::unique_ptr<arma::uvec> indecesPtr(new arma::uvec());
	std::unique_ptr<arma::uvec> suppPtr(new arma::uvec());
	std::unique_ptr<arma::vec> matDotXPtr(new arma::vec());

	(*suppPtr) = arma::find(x > 0.5);
	(*matDotXPtr) = mat * x;

	for (auto jt = suppPtr->cbegin(); jt != suppPtr->cend(); ++jt)
	{
		cnt = 0.0;
		(*indecesPtr) = arma::find((*matDotXPtr) > 1.0);
		for (auto it = (*indecesPtr).cbegin(); it != (*indecesPtr).cend(); ++jt)
		{
			cnt += mat(*it, *jt);
		}

		if (cnt > 0.0)
		{
			(*matDotXPtr) -= mat.col(*jt);
			x(*jt) = 0.0;
		}
	}

	return 0;
}

/**
 * Given a SCP dense matrix and a SCP solution x,
 * return the number of removed columns
 * from x (to make x a prime cover).
 * 
 * @param mat - arma::mat a SCP dense matrix
 * @param obj - arma::vec SCP objective values
 * @param x - arma::vec a SCP dense solution
 * @param zUpp - double the current cost of solution x
 * @return the number of removed columns from x
 */
int baldns_make_prime_cover(const arma::mat &mat, const arma::vec &obj, arma::vec &x, double &zUpp)
{
	int cntRemoved;
	size_t i;
	size_t j;

	std::unique_ptr<arma::vec> matDotXPtr(new arma::vec(mat.n_rows));
	(*matDotXPtr) = mat * x;

	cntRemoved = 0;
	for (j = mat.n_cols; j--;)
	{
		if (x(j) > SC_EPSILON_SMALL)
		{
			x(j) = 0.0;
			for (i = 0; i < mat.n_rows; ++i)
			{
				if ((mat(i, j) > SC_EPSILON_SMALL) && ((*matDotXPtr)(i) < (2.0 - SC_EPSILON_SMALL)))
				{
					x(j) = 1.0;
					break;
				}
			}

			if (x(j) < SC_EPSILON_SMALL)
			{
				(*matDotXPtr) -= mat.col(j);
				zUpp -= obj(j);
				++cntRemoved;
			}
		}
	}

	return cntRemoved;
}

/**
 * Given a SCP dense matrix mat and a solution vector x,
 * return true if x is a cover for mat, false otherwise.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a SCP solution vector
 * @return true if x covers mat, false otherwise
 */
bool baldns_is_cover(const arma::mat &mat, const arma::vec &x)
{
	return arma::all((mat * x) > (1.0 - SC_EPSILON_SMALL));
}

/**
 * Primal heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * Functions description
 * 
 * 1 - f(c, k) = c
 * 
 * 2 - f(c, k) = c / k
 * 
 * 3 - f(c, k) = c 				 	if k < 2 
 *				 c / log2(k)	 	otherwise

 * 4 - f(c, k) = c / k 			 	if k < 2
 * 				 c / k * log2(k) 	otherwise
 * 
 * 5 - f(c, k) = c / k				if k < 3
 * 				 c / k * ln(k)		otherwise
 * 
 * 6 - f(c, k) = c / k^2
 * 
 * 7 - f(c, k) = sqrt(c) / k^2
 * 
 * @param mat - arma::mat SCP matrix
 * @param obj - arma::vec SCP objective values
 * @param x - arma::vec a solution for the SCP
 * @param whichFunc - select function for heuristic (from 1 to 7)
 * @return the value of the best primal solution found
 */
double baldns_heur_primal_0(arma::mat &mat, arma::vec &obj,
							arma::vec &x, const int whichFunc)
{
	int colIdx;
	int rowIdx;
	size_t i;
	size_t j;
	double bestVal;
	double val;
	double zUpp;
	double cnt;
	double (*func)(const double, const double);

	std::unique_ptr<std::vector<std::pair<int, int>>> notCoveredRowsPtr(new std::vector<std::pair<int, int>>); // set R on papers

	// all the functions defined by Balas and Ho
	// plus the last two defined by Vasko and Wilson
	switch (whichFunc)
	{
	case 1:
		func = [](const double c, const double k) -> double { return c; };
		break;
	case 2:
		func = [](const double c, const double k) -> double { return c / k; };
		break;
	case 3:
		func = [](const double c, const double k) -> double { return k < 2 ? c : c / log2(k); };
		break;
	case 4:
		func = [](const double c, const double k) -> double { return k < 2 ? c / k : c / k * log2(k); };
		break;
	case 5:
		func = [](const double c, const double k) -> double { return k < 3 ? c / k : c / k * log(k); };
		break;
	case 6:
		func = [](const double c, const double k) -> double { return c / (k * k); };
		break;
	case 7:
		func = [](const double c, const double k) -> double { return sqrt(c) / (k * k); };
		break;
	default:
		func = [](const double c, const double k) -> double { return k < 2 ? c : c / log2(k); };
		break;
	}

	// get the starting value of the current solution x
	zUpp = arma::dot(obj, x);

	// find rows not already covered and put them in set R
	for (i = mat.n_rows; i--;)
	{
		val = arma::dot(mat.row(i), x);
		cnt = round(arma::sum(mat.row(i)));

		if (fabs(val) < SC_EPSILON_SMALL)
		{
			notCoveredRowsPtr->push_back(std::make_pair(cnt, i));
		}
	}

	// sort not covered rows by decreasing number of
	// non-zero elements in the row (read notCoveredRowsPtr from back to front)
	std::sort(notCoveredRowsPtr->begin(), notCoveredRowsPtr->end(), [](std::pair<int, int> a, std::pair<int, int> b) -> bool { return a.first > b.first; });

	while (notCoveredRowsPtr->size() > 0)
	{
		// get last element of set R
		rowIdx = notCoveredRowsPtr->back().second;
		notCoveredRowsPtr->pop_back();

		bestVal = INFINITY;
		colIdx = -1;
		for (j = 0; j < mat.n_cols; ++j)
		{
			// if mat[row, col] is 0 or if x(col) is already taken, skip this column
			if ((fabs(mat(rowIdx, j)) < SC_EPSILON_SMALL) || (x(j) > SC_EPSILON_SMALL))
			{
				continue;
			}

			val = arma::sum(mat.col(j));

			// use the column j that minimise the value
			// of the selected function
			if (func(obj(j), val) < bestVal)
			{
				bestVal = func(obj(j), val);
				colIdx = j;
			}
		}

		// update solution and objective value
		x(colIdx) = 1.0;
		zUpp += obj(colIdx);

		// remove covered rows from set R
		for (auto it = notCoveredRowsPtr->begin(); it != notCoveredRowsPtr->end();)
		{
			if (fabs(mat((*it).second, colIdx) - 1.0) < SC_EPSILON_SMALL)
			{
				notCoveredRowsPtr->erase(it);
			}
			else
			{
				++it;
			}
		}
	}

	// make the cover found a prime cover
	baldns_make_prime_cover(mat, obj, x, zUpp);

	return zUpp;
}

/**
 * Primal heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * @param mat - arma::mat SCP matrix
 * @param obj - arma::vec SCP objective values
 * @param x - arma::vec a solution for the SCP
 * @return the value of the best primal solution found
 */
double baldns_heur_primal_12(arma::mat &mat, arma::vec &obj, arma::vec &x)
{
	double zu, zu1, zu2;

	std::unique_ptr<arma::vec> x1Ptr(new arma::vec());
	std::unique_ptr<arma::vec> x2Ptr(new arma::vec());

	zu = baldns_heur_primal_0(mat, obj, x, 3);

	// First round
	baldns_over_sat_rows(mat, x);

	zu1 = baldns_heur_primal_0(mat, obj, *x1Ptr, 1);
	zu2 = baldns_heur_primal_0(mat, obj, *x2Ptr, 2);

	if ((zu1 < zu2) && (zu1 < zu))
	{
		x = *x1Ptr;
		zu = zu1;
	}
	else if ((zu2 < zu1) && (zu2 < zu))
	{
		x = *x1Ptr;
		zu = zu2;
	}

	// Second round
	baldns_over_sat_rows(mat, x);

	zu1 = baldns_heur_primal_0(mat, obj, *x1Ptr, 4);
	zu2 = baldns_heur_primal_0(mat, obj, *x2Ptr, 5);

	if ((zu1 < zu2) && (zu1 < zu))
	{
		x = *x1Ptr;
		zu = zu1;
	}
	else if ((zu2 < zu1) && (zu2 < zu))
	{
		x = *x1Ptr;
		zu = zu2;
	}

	return zu;
}

double baldns_heur_primal_5b(arma::mat &mat, arma::vec &obj, arma::vec &x,
							 arma::vec &s, arma::vec &u)
{
	int cntCoveredRows;
	int rowIdx;
	size_t i;
	double zUpp;
	double val;

	std::unique_ptr<std::unordered_set<int>> rSetPtr;

	std::unique_ptr<arma::uvec> indecesPtr(new arma::uvec());
	std::unique_ptr<arma::vec> matDotXPtr(new arma::vec());

	zUpp = 0.0;
	(*indecesPtr) = arma::find(s < SC_EPSILON_SMALL);
	for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
	{
		x(*jt) = 1.0;
		zUpp += obj(*jt);
	}

	baldns_make_prime_cover(mat, obj, x, zUpp);

	(*matDotXPtr) = mat * x;
	cntCoveredRows = 0;
	for (i = mat.n_rows; i--;)
	{
		if (fabs((*matDotXPtr)(i)) < SC_EPSILON_SMALL)
		{
			rSetPtr->insert(i);
		}
		else
		{
			++cntCoveredRows;
		}
	}
	//printf("bhp5 ok4 cvdrows=%d rsetlen=%d\n", cvdrows, rsetlen);

	while (rSetPtr->size() > 0)
	{
		// get a row not covered
		rowIdx = *(rSetPtr->begin());
		rSetPtr->erase(rowIdx);

		val = INFINITY;
		(*indecesPtr) = arma::find(mat.row(rowIdx) > (1.0 - SC_EPSILON_SMALL));
		for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
		{
			if (s(*jt) < val)
			{
				val = s(*jt);
			}
		}

		u(rowIdx) += val;

		for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
		{
			s(*jt) -= val;
		}

		(*indecesPtr) = arma::find(s < SC_EPSILON_SMALL);
		for (auto jt = indecesPtr->cbegin(); jt != indecesPtr->cend(); ++jt)
		{
			x(*jt) = 1.0;
			zUpp += obj(*jt);
		}

		baldns_make_prime_cover(mat, obj, x, zUpp);

		(*matDotXPtr) = mat * x;
		cntCoveredRows = 0;
		for (i = mat.n_rows; i--;)
		{
			if (fabs((*matDotXPtr)(i)) < SC_EPSILON_SMALL)
			{
				rSetPtr->insert(i);
			}
			else
			{
				++cntCoveredRows;
			}
		}
	}

	baldns_make_prime_cover(mat, obj, x, zUpp);

	return zUpp;
}

/**
 * Given a SCP dense matrix mat, the objective vector
 * obj and a dual solution u, return true if u is a dual
 * solution for mat and obj, false otherwise.
 * 
 * @param mat - arma::mat SCP dense matrix
 * @param obj - arma::vec objective vector
 * @param u - arma::vec a SCP dual solution
 * @return true if u is a dual solution for mat and obj, false otherwise
 */
bool baldns_is_dual_sol(arma::mat &mat, arma::vec &obj, arma::vec &u)
{
	return arma::all((obj.t() - (u.t() * mat)) >= 0.0);
}

/**
 * Dual heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * Providing a feasible primal solution x and the reduced costs vector s (initialized
 * as s := obj), this function returns a dual solution u and the reduced costs vector
 * associated to u.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a primal solution
 * @param u - arma::vec dual vector
 * @param s - arma::vec reduced costs vector
 * @return the value of the dual solution
 */
double baldns_heur_dual_1(arma::mat &mat, arma::vec &x, arma::vec &u,
						  arma::vec &s)
{
	bool firstTime;
	size_t i;
	size_t j;
	size_t rowIdx;
	double cnt;
	double zLow;

	std::unique_ptr<std::vector<std::pair<double, int>>> rSetPtr(new std::vector<std::pair<double, int>>);
	std::unique_ptr<arma::vec> matDotXPtr(new arma::vec(mat.n_rows));

	zLow = 0.0;
	u.fill(0.0);
	(*matDotXPtr) = mat * x;

	for (i = 0; i < mat.n_rows; ++i)
	{
		// R := M intersection T(x)
		if (fabs((*matDotXPtr)(i)-1.0) < SC_EPSILON_SMALL)
		{
			cnt = arma::sum(mat.row(i));
			rSetPtr->push_back(std::make_pair(cnt, i));
		}
	}

	std::sort(rSetPtr->begin(), rSetPtr->end(), [](std::pair<double, int> a, std::pair<double, int> b) -> bool { return a.first > b.first; });

	firstTime = true;
	while (rSetPtr->size() > 0)
	{
		rowIdx = rSetPtr->back().second;
		rSetPtr->pop_back();

		u(rowIdx) = DBL_MAX;
		for (j = 0; j < mat.n_cols; ++j)
		{
			u(rowIdx) = (mat(rowIdx, j) > SC_EPSILON_SMALL) && (s(j) < u(rowIdx)) ? s(j) : u(rowIdx);
		}
		zLow += u(rowIdx);

		s -= u(rowIdx) * mat.row(rowIdx).t();

		if ((rSetPtr->size() == 0) && firstTime)
		{
			firstTime = false;
			rSetPtr->clear();

			for (i = 0; i < mat.n_rows; ++i)
			{
				// R := M / T(x)
				if (!(fabs((*matDotXPtr)(i)-1.0) < SC_EPSILON_SMALL))
				{
					cnt = arma::sum(mat.row(i));
					rSetPtr->push_back(std::make_pair(cnt, i));
				}
			}

			std::sort(rSetPtr->begin(), rSetPtr->end(), [](std::pair<double, int> a, std::pair<double, int> b) -> bool { return a.first > b.first; });
		}
	}

	return zLow;
}

/**
 * Dual heuristic for the SCP as described in "Set Covering algorithms using cutting
 * planes, heuristics, and subgradient optimization: a computational study"
 * by Egon Balas and Andrew Ho - Carnegie-Mellon University, Pittsburgh, PA, U.S.A.
 * 
 * @param mat - arma::mat SCP matrix
 * @param x - arma::vec a primal solution
 * @param u - arma::vec dual vector 
 * @param s - arma::vec reduced costs vector
 * @param zUpp - the value of current solution (x dot obj)
 * @return 
 */
double baldns_heur_dual_3(arma::mat &mat, arma::vec &x, arma::vec &u,
						  arma::vec &s, const double zUpp)
{
	int rowIdx;
	size_t i;
	double sDotX;
	double zLow;
	double val;

	std::unique_ptr<std::vector<std::pair<double, int>>> rSetPtr(new std::vector<std::pair<double, int>>);

	sDotX = arma::dot(s, x);
	zLow = arma::sum(u);

	if (sDotX >= (zUpp - zLow))
	{
		return 0;
	}

	for (i = 0; i < mat.n_rows; ++i)
	{

		// No need to generate R and T(x) sets: val says how
		// much a row is covered and if val < 1 (minimum
		// cover) skip the row
		val = arma::dot(mat.row(i), x);

		if ((u(i) > 0) && (val > 1.0))
		{
			rSetPtr->push_back(std::make_pair(val, i));
		}
	}

	if (rSetPtr->size() == 0)
	{
		return 0;
	}

	std::sort(rSetPtr->begin(), rSetPtr->end(), [](std::pair<double, int> a, std::pair<double, int> b) -> bool { return a.first > b.first; });

	while (sDotX < (zUpp - zLow - SC_EPSILON_SMALL))
	{
		rowIdx = rSetPtr->back().second;
		rSetPtr->pop_back();

		val = u(rowIdx);
		s += val * mat.row(rowIdx);
		sDotX += val * arma::dot(mat.row(rowIdx), x);

		zLow -= val;
		u(rowIdx) = 0.0;
	}

	return zLow;
}

double baldns_dual_subgrad(arma::mat &mat, arma::vec &obj, arma::vec &x,
							 arma::vec &u)
{
	int cntIter;
	int cntUnchgIter;
	size_t i;
	size_t j;
	double coeffL;
	double zUpp;
	double zLow;
	double zLowPrev;
	double sigma;
	double subgradNorm;

	int k;
	int omega;
	double lambda;
	double epsilon;
	double delta;

	std::unique_ptr<std::unordered_set<int>> nSetPtr;
	std::unique_ptr<arma::vec> redCostsPtr;
	std::unique_ptr<arma::vec> tmpVecPtr;

	for (j = 0; j < mat.n_cols; ++j)
	{
		nSetPtr->insert(j);
	}

	(*redCostsPtr) = obj - (u * mat);

	baldns_heur_dual_1(mat, x, u, *redCostsPtr);

	zUpp = arma::dot(obj, x);
	zLow = arma::sum(u);


	cntIter = 0;
	cntUnchgIter = 0;
	while (zUpp > zLow)	// Solve L(u(t)) and define u(t+1)
	{
		for (i = 0; i < mat.n_rows; ++i) // Cover optimally the rows in M
		{
			(*tmpVecPtr) = obj - (u * mat);
			j = tmpVecPtr->index_min();
			x(j) = 1.0;
			nSetPtr->erase(j);
		}

		for (auto jt = nSetPtr->cbegin(); jt != nSetPtr->cend(); ++jt) // Assign values to remaining x_j(u(t))
		{
			if (obj(*jt) < arma::dot(u, mat.col(*jt)))
			{
				x(*jt) = 1.0;
			} else
			{
				x(*jt) = 0.0;
			}
		}

		coeffL = arma::sum(u) + arma::dot((obj - (u * mat)), x);
		zLow = std::max(zLow, coeffL);

		// TODO: Compute subgradient: put it in tmpVec
		//for (auto it = )
		{

		}

		if (fabs(zLow - zLowPrev) < SC_EPSILON_SMALL)
		{
			++cntUnchgIter;
		}
		zLowPrev = zLow;

		if (cntUnchgIter >= k)
		{
			lambda = lambda / 2.0;
			cntUnchgIter = 0;
		}

		// Compute step length sigma
		subgradNorm = arma::norm((*tmpVecPtr));
		sigma = lambda * (zUpp - zLow) / subgradNorm;

		// Stop conditions
		if ((sigma < epsilon) || (subgradNorm < delta) || (cntIter >= omega))
		{
			break;
		}

		// Update dual solution u


		++cntIter;
	}

	return 0;
}